{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello! Iffatusy Syaharani - 180411100099 Mata Kuliah Penambangan Data","title":"Home"},{"location":"#hello","text":"Iffatusy Syaharani - 180411100099","title":"Hello!"},{"location":"#mata-kuliah","text":"Penambangan Data","title":"Mata Kuliah"},{"location":"DataMiningTg2/","text":"Mengukur Jarak Data Mengukur Jarak Tipe Numerik from IPython.display import Image,display; display(Image(filename=\"d1.PNG\")) display(Image(filename=\"d2.PNG\")) display(Image(filename=\"d3.PNG\")) display(Image(filename=\"d4.PNG\")) display(Image(filename=\"d5.PNG\")) display(Image(filename=\"d6.PNG\")) Tugas II (Mengukur Jarak pada Data Real) from scipy import stats import pandas as pd df = pd.read_csv('Teaching Assistant Evaluation Data Set.csv') a=df.iloc[13:17] a .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Whether of not the TA is a native English speaker Course instructor Course Summer or regular semester Class size Class attribute 13 2.0 6.0 17.0 2.0 39.0 3.0 14 2.0 6.0 17.0 2.0 42.0 2.0 15 2.0 6.0 17.0 2.0 43.0 2.0 16 2.0 7.0 11.0 2.0 10.0 2.0 Agar mempermudah penghitungan data maka jenis data di identifikasi terlebih dahulu Saya menuliskan index dari kolom binary=[0,3] ordinal=[5] num=[4] categorical=[1,2] from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Ordinal\"]+[\"Categorical\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[0]+[0]+[0]+[0], [\"v1-v3\"]+[0]+[0]+[0]+[0]+[0], [\"v1-v4\"]+[0]+[0]+[0]+[0]+[0], [\"v2-v3\"]+[0]+[0]+[0]+[0]+[0], [\"v2-v4\"]+[0]+[0]+[0]+[0]+[0], [\"v3-v4\"]+[0]+[0]+[0]+[0]+[0], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) Data Jarak Numeric Ordinal Categorical Binary v1-v2 0 0 0 0 0 v1-v3 0 0 0 0 0 v1-v4 0 0 0 0 0 v2-v3 0 0 0 0 0 v2-v4 0 0 0 0 0 v3-v4 0 0 0 0 0 Jarak Numeric Pada Penghitungan Data kali ini saya memakai Chord Distance def chordDist(v1,v2,jnis): jmlh=0 normv1=0 normv2=0 for x in range (len(jnis)): normv1=normv1+(int(a.values.tolist()[v1][jnis[x]])**2) normv2=normv2+(int(a.values.tolist()[v2][jnis[x]])**2) jmlh=jmlh+(int(a.values.tolist()[v1][jnis[x]])*int(a.values.tolist()[v2][jnis[x]])) return ((2-(2*jmlh/(normv1*normv2)))**0.5) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Ordinal\"]+[\"Categorical\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[chordDist(0,1,num)]+[0]+[0]+[0], [\"v1-v3\"]+[0]+[chordDist(0,2,num)]+[0]+[0]+[0], [\"v1-v4\"]+[0]+[chordDist(0,3,num)]+[0]+[0]+[0], [\"v2-v3\"]+[0]+[chordDist(1,2,num)]+[0]+[0]+[0], [\"v2-v4\"]+[0]+[chordDist(1,3,num)]+[0]+[0]+[0], [\"v3-v4\"]+[0]+[chordDist(2,3,num)]+[0]+[0]+[0], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) Data Jarak Numeric Ordinal Categorical Binary v1-v2 0 1.413781807344754 0 0 0 v1-v3 0 1.4137918496568833 0 0 0 v1-v4 0 1.412399304329974 0 0 0 v2-v3 0 1.4138219761652913 0 0 0 v2-v4 0 1.4125289714685838 0 0 0 v3-v4 0 1.412568170818422 0 0 0 Jarak Ordinal display(Image(filename=\"d12.PNG\")) display(Image(filename=\"d13.PNG\")) def ordDist(v1,v2,jns): jmlh=0 for x in range (len(jns)): z1=int(a.values.tolist()[v1][jns[x]])-1 z2=int(a.values.tolist()[v2][jns[x]])-1 jmlh=jmlh+chordDist(z1,z2,jns) return (jmlh) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Ordinal\"]+[\"Categorical\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[chordDist(0,1,num)]+[ordDist(0,1,ordinal)]+[0]+[0], [\"v1-v3\"]+[0]+[chordDist(0,2,num)]+[ordDist(0,2,ordinal)]+[0]+[0], [\"v1-v4\"]+[0]+[chordDist(0,3,num)]+[ordDist(0,3,ordinal)]+[0]+[0], [\"v2-v3\"]+[0]+[chordDist(1,2,num)]+[ordDist(1,2,ordinal)]+[0]+[0], [\"v2-v4\"]+[0]+[chordDist(1,3,num)]+[ordDist(1,3,ordinal)]+[0]+[0], [\"v3-v4\"]+[0]+[chordDist(2,3,num)]+[ordDist(2,3,ordinal)]+[0]+[0], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) Data Jarak Numeric Ordinal Categorical Binary v1-v2 0 1.413781807344754 1.224744871391589 0 0 v1-v3 0 1.4137918496568833 1.224744871391589 0 0 v1-v4 0 1.412399304329974 1.224744871391589 0 0 v2-v3 0 1.4138219761652913 1.224744871391589 0 0 v2-v4 0 1.4125289714685838 1.224744871391589 0 0 v3-v4 0 1.412568170818422 1.224744871391589 0 0 Jarak Categorical display(Image(filename=\"d9.PNG\")) display(Image(filename=\"d10.PNG\")) display(Image(filename=\"d11.PNG\")) def categoricalDist(v1,v2,jnis): jmlh=0 for x in range (len(jnis)): if (a.values.tolist()[v1][jnis[x]])!=(a.values.tolist()[v2][jnis[x]]): jmlh=jmlh+1 return (jmlh) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Ordinal\"]+[\"Categorical\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[chordDist(0,1,num)]+[ordDist(0,1,ordinal)]+[categoricalDist(0,1,categorical)]+[0], [\"v1-v3\"]+[0]+[chordDist(0,2,num)]+[ordDist(0,2,ordinal)]+[categoricalDist(0,2,categorical)]+[0], [\"v1-v4\"]+[0]+[chordDist(0,3,num)]+[ordDist(0,3,ordinal)]+[categoricalDist(0,3,categorical)]+[0], [\"v2-v3\"]+[0]+[chordDist(1,2,num)]+[ordDist(1,2,ordinal)]+[categoricalDist(1,2,categorical)]+[0], [\"v2-v4\"]+[0]+[chordDist(1,3,num)]+[ordDist(1,3,ordinal)]+[categoricalDist(1,3,categorical)]+[0], [\"v3-v4\"]+[0]+[chordDist(2,3,num)]+[ordDist(2,3,ordinal)]+[categoricalDist(2,3,categorical)]+[0], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) Data Jarak Numeric Ordinal Categorical Binary v1-v2 0 1.413781807344754 1.224744871391589 0 0 v1-v3 0 1.4137918496568833 1.224744871391589 0 0 v1-v4 0 1.412399304329974 1.224744871391589 2 0 v2-v3 0 1.4138219761652913 1.224744871391589 0 0 v2-v4 0 1.4125289714685838 1.224744871391589 2 0 v3-v4 0 1.412568170818422 1.224744871391589 2 0 Jarak Binary display(Image(filename=\"d7.PNG\")) display(Image(filename=\"d8.PNG\")) def binaryDist(v1,v2,jnis): q=0 r=0 s=0 t=0 for x in range (len(jnis)): if (int(a.values.tolist()[v1][jnis[x]]))==1 and (int(a.values.tolist()[v2][jnis[x]]))==1: q=q+1 elif (int(a.values.tolist()[v1][jnis[x]]))==1 and (int(a.values.tolist()[v2][jnis[x]]))==2: r=r+1 elif (int(a.values.tolist()[v1][jnis[x]]))==2 and (int(a.values.tolist()[v2][jnis[x]]))==1: s=s+1 else: t=t+1 return ((r+s)/(q+r+s+t)) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Ordinal\"]+[\"Categorical\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[chordDist(0,1,num)]+[ordDist(0,1,ordinal)]+[categoricalDist(0,1,categorical)]+[binaryDist(0,1,binary)], [\"v1-v3\"]+[0]+[chordDist(0,2,num)]+[ordDist(0,2,ordinal)]+[categoricalDist(0,2,categorical)]+[binaryDist(0,2,binary)], [\"v1-v4\"]+[0]+[chordDist(0,3,num)]+[ordDist(0,3,ordinal)]+[categoricalDist(0,3,categorical)]+[binaryDist(0,3,binary)], [\"v2-v3\"]+[0]+[chordDist(1,2,num)]+[ordDist(1,2,ordinal)]+[categoricalDist(1,2,categorical)]+[binaryDist(1,2,binary)], [\"v2-v4\"]+[0]+[chordDist(1,3,num)]+[ordDist(1,3,ordinal)]+[categoricalDist(1,3,categorical)]+[binaryDist(1,3,binary)], [\"v3-v4\"]+[0]+[chordDist(2,3,num)]+[ordDist(2,3,ordinal)]+[categoricalDist(2,3,categorical)]+[binaryDist(2,3,binary)], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) Data Jarak Numeric Ordinal Categorical Binary v1-v2 0 1.413781807344754 1.224744871391589 0 0.0 v1-v3 0 1.4137918496568833 1.224744871391589 0 0.0 v1-v4 0 1.412399304329974 1.224744871391589 2 0.0 v2-v3 0 1.4138219761652913 1.224744871391589 0 0.0 v2-v4 0 1.4125289714685838 1.224744871391589 2 0.0 v3-v4 0 1.412568170818422 1.224744871391589 2 0.0 Jarak Campuran display(Image(filename=\"d14.PNG\")) display(Image(filename=\"d15.PNG\")) Pada Data yang saya ambil tidak memiliki missing value sehingga nilai delta = 1 Jarak = Jumlah Jarak setiap jenis/Jumlah Jenis def jarak(v1,v2): return ((chordDist(v1,v2,num)+ordDist(v1,v2,ordinal)+categoricalDist(v1,v2,categorical)+binaryDist(v1,v2,binary))/4) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Ordinal\"]+[\"Categorical\"]+[\"Binary\"], [\"v1-v2\"]+[\"{:.2f}\".format(jarak(0,1))]+[\"{:.2f}\".format(chordDist(0,1,num))]+[\"{:.2f}\".format(ordDist(0,1,ordinal))]+[categoricalDist(0,1,categorical)]+[binaryDist(0,1,binary)], [\"v1-v3\"]+[\"{:.2f}\".format(jarak(0,2))]+[\"{:.2f}\".format(chordDist(0,2,num))]+[\"{:.2f}\".format(ordDist(0,2,ordinal))]+[categoricalDist(0,2,categorical)]+[binaryDist(0,2,binary)], [\"v1-v4\"]+[\"{:.2f}\".format(jarak(0,3))]+[\"{:.2f}\".format(chordDist(0,3,num))]+[\"{:.2f}\".format(ordDist(0,3,ordinal))]+[categoricalDist(0,3,categorical)]+[binaryDist(0,3,binary)], [\"v2-v3\"]+[\"{:.2f}\".format(jarak(1,2))]+[\"{:.2f}\".format(chordDist(1,2,num))]+[\"{:.2f}\".format(ordDist(1,2,ordinal))]+[categoricalDist(1,2,categorical)]+[binaryDist(1,2,binary)], [\"v2-v4\"]+[\"{:.2f}\".format(jarak(1,3))]+[\"{:.2f}\".format(chordDist(1,3,num))]+[\"{:.2f}\".format(ordDist(1,3,ordinal))]+[categoricalDist(1,3,categorical)]+[binaryDist(1,3,binary)], [\"v3-v4\"]+[\"{:.2f}\".format(jarak(2,3))]+[\"{:.2f}\".format(chordDist(2,3,num))]+[\"{:.2f}\".format(ordDist(2,3,ordinal))]+[categoricalDist(2,3,categorical)]+[binaryDist(2,3,binary)], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) Data Jarak Numeric Ordinal Categorical Binary v1-v2 0.66 1.41 1.22 0 0.0 v1-v3 0.66 1.41 1.22 0 0.0 v1-v4 1.16 1.41 1.22 2 0.0 v2-v3 0.66 1.41 1.22 0 0.0 v2-v4 1.16 1.41 1.22 2 0.0 v3-v4 1.16 1.41 1.22 2 0.0","title":"Tugas 2"},{"location":"DataMiningTg2/#mengukur-jarak-data","text":"","title":"Mengukur Jarak Data"},{"location":"DataMiningTg2/#mengukur-jarak-tipe-numerik","text":"from IPython.display import Image,display; display(Image(filename=\"d1.PNG\")) display(Image(filename=\"d2.PNG\")) display(Image(filename=\"d3.PNG\")) display(Image(filename=\"d4.PNG\")) display(Image(filename=\"d5.PNG\")) display(Image(filename=\"d6.PNG\"))","title":"Mengukur Jarak Tipe Numerik"},{"location":"DataMiningTg2/#tugas-ii-mengukur-jarak-pada-data-real","text":"from scipy import stats import pandas as pd df = pd.read_csv('Teaching Assistant Evaluation Data Set.csv') a=df.iloc[13:17] a .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Whether of not the TA is a native English speaker Course instructor Course Summer or regular semester Class size Class attribute 13 2.0 6.0 17.0 2.0 39.0 3.0 14 2.0 6.0 17.0 2.0 42.0 2.0 15 2.0 6.0 17.0 2.0 43.0 2.0 16 2.0 7.0 11.0 2.0 10.0 2.0","title":"Tugas II (Mengukur Jarak pada Data Real)"},{"location":"DataMiningTg2/#agar-mempermudah-penghitungan-data-maka-jenis-data-di-identifikasi-terlebih-dahulu","text":"","title":"Agar mempermudah penghitungan data maka jenis data di identifikasi terlebih dahulu"},{"location":"DataMiningTg2/#saya-menuliskan-index-dari-kolom","text":"binary=[0,3] ordinal=[5] num=[4] categorical=[1,2] from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Ordinal\"]+[\"Categorical\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[0]+[0]+[0]+[0], [\"v1-v3\"]+[0]+[0]+[0]+[0]+[0], [\"v1-v4\"]+[0]+[0]+[0]+[0]+[0], [\"v2-v3\"]+[0]+[0]+[0]+[0]+[0], [\"v2-v4\"]+[0]+[0]+[0]+[0]+[0], [\"v3-v4\"]+[0]+[0]+[0]+[0]+[0], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) Data Jarak Numeric Ordinal Categorical Binary v1-v2 0 0 0 0 0 v1-v3 0 0 0 0 0 v1-v4 0 0 0 0 0 v2-v3 0 0 0 0 0 v2-v4 0 0 0 0 0 v3-v4 0 0 0 0 0","title":"Saya menuliskan index dari kolom"},{"location":"DataMiningTg2/#jarak-numeric","text":"","title":"Jarak Numeric"},{"location":"DataMiningTg2/#pada-penghitungan-data-kali-ini-saya-memakai-chord-distance","text":"def chordDist(v1,v2,jnis): jmlh=0 normv1=0 normv2=0 for x in range (len(jnis)): normv1=normv1+(int(a.values.tolist()[v1][jnis[x]])**2) normv2=normv2+(int(a.values.tolist()[v2][jnis[x]])**2) jmlh=jmlh+(int(a.values.tolist()[v1][jnis[x]])*int(a.values.tolist()[v2][jnis[x]])) return ((2-(2*jmlh/(normv1*normv2)))**0.5) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Ordinal\"]+[\"Categorical\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[chordDist(0,1,num)]+[0]+[0]+[0], [\"v1-v3\"]+[0]+[chordDist(0,2,num)]+[0]+[0]+[0], [\"v1-v4\"]+[0]+[chordDist(0,3,num)]+[0]+[0]+[0], [\"v2-v3\"]+[0]+[chordDist(1,2,num)]+[0]+[0]+[0], [\"v2-v4\"]+[0]+[chordDist(1,3,num)]+[0]+[0]+[0], [\"v3-v4\"]+[0]+[chordDist(2,3,num)]+[0]+[0]+[0], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) Data Jarak Numeric Ordinal Categorical Binary v1-v2 0 1.413781807344754 0 0 0 v1-v3 0 1.4137918496568833 0 0 0 v1-v4 0 1.412399304329974 0 0 0 v2-v3 0 1.4138219761652913 0 0 0 v2-v4 0 1.4125289714685838 0 0 0 v3-v4 0 1.412568170818422 0 0 0","title":"Pada Penghitungan Data kali ini saya memakai Chord Distance"},{"location":"DataMiningTg2/#jarak-ordinal","text":"display(Image(filename=\"d12.PNG\")) display(Image(filename=\"d13.PNG\")) def ordDist(v1,v2,jns): jmlh=0 for x in range (len(jns)): z1=int(a.values.tolist()[v1][jns[x]])-1 z2=int(a.values.tolist()[v2][jns[x]])-1 jmlh=jmlh+chordDist(z1,z2,jns) return (jmlh) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Ordinal\"]+[\"Categorical\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[chordDist(0,1,num)]+[ordDist(0,1,ordinal)]+[0]+[0], [\"v1-v3\"]+[0]+[chordDist(0,2,num)]+[ordDist(0,2,ordinal)]+[0]+[0], [\"v1-v4\"]+[0]+[chordDist(0,3,num)]+[ordDist(0,3,ordinal)]+[0]+[0], [\"v2-v3\"]+[0]+[chordDist(1,2,num)]+[ordDist(1,2,ordinal)]+[0]+[0], [\"v2-v4\"]+[0]+[chordDist(1,3,num)]+[ordDist(1,3,ordinal)]+[0]+[0], [\"v3-v4\"]+[0]+[chordDist(2,3,num)]+[ordDist(2,3,ordinal)]+[0]+[0], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) Data Jarak Numeric Ordinal Categorical Binary v1-v2 0 1.413781807344754 1.224744871391589 0 0 v1-v3 0 1.4137918496568833 1.224744871391589 0 0 v1-v4 0 1.412399304329974 1.224744871391589 0 0 v2-v3 0 1.4138219761652913 1.224744871391589 0 0 v2-v4 0 1.4125289714685838 1.224744871391589 0 0 v3-v4 0 1.412568170818422 1.224744871391589 0 0","title":"Jarak Ordinal"},{"location":"DataMiningTg2/#jarak-categorical","text":"display(Image(filename=\"d9.PNG\")) display(Image(filename=\"d10.PNG\")) display(Image(filename=\"d11.PNG\")) def categoricalDist(v1,v2,jnis): jmlh=0 for x in range (len(jnis)): if (a.values.tolist()[v1][jnis[x]])!=(a.values.tolist()[v2][jnis[x]]): jmlh=jmlh+1 return (jmlh) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Ordinal\"]+[\"Categorical\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[chordDist(0,1,num)]+[ordDist(0,1,ordinal)]+[categoricalDist(0,1,categorical)]+[0], [\"v1-v3\"]+[0]+[chordDist(0,2,num)]+[ordDist(0,2,ordinal)]+[categoricalDist(0,2,categorical)]+[0], [\"v1-v4\"]+[0]+[chordDist(0,3,num)]+[ordDist(0,3,ordinal)]+[categoricalDist(0,3,categorical)]+[0], [\"v2-v3\"]+[0]+[chordDist(1,2,num)]+[ordDist(1,2,ordinal)]+[categoricalDist(1,2,categorical)]+[0], [\"v2-v4\"]+[0]+[chordDist(1,3,num)]+[ordDist(1,3,ordinal)]+[categoricalDist(1,3,categorical)]+[0], [\"v3-v4\"]+[0]+[chordDist(2,3,num)]+[ordDist(2,3,ordinal)]+[categoricalDist(2,3,categorical)]+[0], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) Data Jarak Numeric Ordinal Categorical Binary v1-v2 0 1.413781807344754 1.224744871391589 0 0 v1-v3 0 1.4137918496568833 1.224744871391589 0 0 v1-v4 0 1.412399304329974 1.224744871391589 2 0 v2-v3 0 1.4138219761652913 1.224744871391589 0 0 v2-v4 0 1.4125289714685838 1.224744871391589 2 0 v3-v4 0 1.412568170818422 1.224744871391589 2 0","title":"Jarak Categorical"},{"location":"DataMiningTg2/#jarak-binary","text":"display(Image(filename=\"d7.PNG\")) display(Image(filename=\"d8.PNG\")) def binaryDist(v1,v2,jnis): q=0 r=0 s=0 t=0 for x in range (len(jnis)): if (int(a.values.tolist()[v1][jnis[x]]))==1 and (int(a.values.tolist()[v2][jnis[x]]))==1: q=q+1 elif (int(a.values.tolist()[v1][jnis[x]]))==1 and (int(a.values.tolist()[v2][jnis[x]]))==2: r=r+1 elif (int(a.values.tolist()[v1][jnis[x]]))==2 and (int(a.values.tolist()[v2][jnis[x]]))==1: s=s+1 else: t=t+1 return ((r+s)/(q+r+s+t)) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Ordinal\"]+[\"Categorical\"]+[\"Binary\"], [\"v1-v2\"]+[0]+[chordDist(0,1,num)]+[ordDist(0,1,ordinal)]+[categoricalDist(0,1,categorical)]+[binaryDist(0,1,binary)], [\"v1-v3\"]+[0]+[chordDist(0,2,num)]+[ordDist(0,2,ordinal)]+[categoricalDist(0,2,categorical)]+[binaryDist(0,2,binary)], [\"v1-v4\"]+[0]+[chordDist(0,3,num)]+[ordDist(0,3,ordinal)]+[categoricalDist(0,3,categorical)]+[binaryDist(0,3,binary)], [\"v2-v3\"]+[0]+[chordDist(1,2,num)]+[ordDist(1,2,ordinal)]+[categoricalDist(1,2,categorical)]+[binaryDist(1,2,binary)], [\"v2-v4\"]+[0]+[chordDist(1,3,num)]+[ordDist(1,3,ordinal)]+[categoricalDist(1,3,categorical)]+[binaryDist(1,3,binary)], [\"v3-v4\"]+[0]+[chordDist(2,3,num)]+[ordDist(2,3,ordinal)]+[categoricalDist(2,3,categorical)]+[binaryDist(2,3,binary)], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) Data Jarak Numeric Ordinal Categorical Binary v1-v2 0 1.413781807344754 1.224744871391589 0 0.0 v1-v3 0 1.4137918496568833 1.224744871391589 0 0.0 v1-v4 0 1.412399304329974 1.224744871391589 2 0.0 v2-v3 0 1.4138219761652913 1.224744871391589 0 0.0 v2-v4 0 1.4125289714685838 1.224744871391589 2 0.0 v3-v4 0 1.412568170818422 1.224744871391589 2 0.0","title":"Jarak Binary"},{"location":"DataMiningTg2/#jarak-campuran","text":"display(Image(filename=\"d14.PNG\")) display(Image(filename=\"d15.PNG\"))","title":"Jarak Campuran"},{"location":"DataMiningTg2/#pada-data-yang-saya-ambil-tidak-memiliki-missing-value-sehingga-nilai-delta-1","text":"","title":"Pada Data yang saya ambil tidak memiliki missing value sehingga nilai delta = 1"},{"location":"DataMiningTg2/#jarak-jumlah-jarak-setiap-jenisjumlah-jenis","text":"def jarak(v1,v2): return ((chordDist(v1,v2,num)+ordDist(v1,v2,ordinal)+categoricalDist(v1,v2,categorical)+binaryDist(v1,v2,binary))/4) from IPython.display import HTML, display import tabulate table=[ [\"Data\"]+[\"Jarak\"]+[\"Numeric\"]+[\"Ordinal\"]+[\"Categorical\"]+[\"Binary\"], [\"v1-v2\"]+[\"{:.2f}\".format(jarak(0,1))]+[\"{:.2f}\".format(chordDist(0,1,num))]+[\"{:.2f}\".format(ordDist(0,1,ordinal))]+[categoricalDist(0,1,categorical)]+[binaryDist(0,1,binary)], [\"v1-v3\"]+[\"{:.2f}\".format(jarak(0,2))]+[\"{:.2f}\".format(chordDist(0,2,num))]+[\"{:.2f}\".format(ordDist(0,2,ordinal))]+[categoricalDist(0,2,categorical)]+[binaryDist(0,2,binary)], [\"v1-v4\"]+[\"{:.2f}\".format(jarak(0,3))]+[\"{:.2f}\".format(chordDist(0,3,num))]+[\"{:.2f}\".format(ordDist(0,3,ordinal))]+[categoricalDist(0,3,categorical)]+[binaryDist(0,3,binary)], [\"v2-v3\"]+[\"{:.2f}\".format(jarak(1,2))]+[\"{:.2f}\".format(chordDist(1,2,num))]+[\"{:.2f}\".format(ordDist(1,2,ordinal))]+[categoricalDist(1,2,categorical)]+[binaryDist(1,2,binary)], [\"v2-v4\"]+[\"{:.2f}\".format(jarak(1,3))]+[\"{:.2f}\".format(chordDist(1,3,num))]+[\"{:.2f}\".format(ordDist(1,3,ordinal))]+[categoricalDist(1,3,categorical)]+[binaryDist(1,3,binary)], [\"v3-v4\"]+[\"{:.2f}\".format(jarak(2,3))]+[\"{:.2f}\".format(chordDist(2,3,num))]+[\"{:.2f}\".format(ordDist(2,3,ordinal))]+[categoricalDist(2,3,categorical)]+[binaryDist(2,3,binary)], ] display(HTML(tabulate.tabulate(table, tablefmt='html'))) Data Jarak Numeric Ordinal Categorical Binary v1-v2 0.66 1.41 1.22 0 0.0 v1-v3 0.66 1.41 1.22 0 0.0 v1-v4 1.16 1.41 1.22 2 0.0 v2-v3 0.66 1.41 1.22 0 0.0 v2-v4 1.16 1.41 1.22 2 0.0 v3-v4 1.16 1.41 1.22 2 0.0","title":"Jarak = Jumlah Jarak setiap jenis/Jumlah Jenis"},{"location":"DataMiningTg3/","text":"Seleksi Fitur Seleksi fitur adalah teknik untuk memilih fitur penting dan relevan terhadap data dan mengurangi fitur yang tidak relevan. Seleksi fitur bertujuan untuk memilih fitur terbaik dari suatu kumpulan data fitur. Banyak cara untuk melakukan seleksi fitur. seperti : - Information Gain - Relief - Fast Correlation Based Filter dll Kali ini Metode yang digunakan adalah Information Gain. Metode Information Gain adalah metode yang menggunakan teknik scoring untuk pembobotan sebuah fitur dengan menggunakan maksimal entropy. Fitur yang dipilih adalah fitur dengan nilai Information Gain yang lebih besar atau sama dengan nilai threshold tertentu. Contoh Data Keputusan Bermain Tenis from IPython.display import Image import pandas as pd import math df=pd.read_csv('feature selection.csv') df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } outlook temperature humidity windy play 0 sunny hot high False no 1 sunny hot high True no 2 overcast hot high False yes 3 rainy mild high False yes 4 rainy cool normal False yes 5 rainy cool normal True no 6 overcast cool normal True yes 7 sunny mild high False no 8 sunny cool normal False yes 9 rainy mild normal False yes 10 sunny mild normal True yes 11 overcast mild high True yes 12 overcast hot normal False yes 13 rainy mild high True no Mencari Entropy Untuk menghitung Information gain perlu dihitung dahulu nilai informasi dalam suatu bits dari suatu kumpulan obyek. Cara penghitungan dilakukan dengan menggunakan konsep entropi. Entropi menyatakan impurity suatu kumpulan obyek . Berikut merupakan definisi dari entropi suatu ruang sampel data (T): Image(\"Entropy.png\") Keterangan : T = ruang sampel data yang di gunakaan untuk data pelatihan n = jumlah partisi Pi = Probability dari Pi terhadap P untuk mempermudah penghitungan saya menggunakan fungsi pembantu, seperti fungsi banyak_elemen untuk mengecek ada berapa elemen dalam sebuah kolom atau fiture/class. # menentukan value atau jenis pada atribut def banyak_elemen (kolom, data): kelas=[] for i in range (len(data)): if data.values.tolist()[i][kolom] not in kelas: kelas.append(data.values.tolist()[i][kolom]) return kelas kelas=banyak_elemen(df.shape[1]-1, df) outlook=banyak_elemen(df.shape[1]-5,df) temp=banyak_elemen(df.shape[1]-4,df) humidity=banyak_elemen(df.shape[1]-3,df) windy=banyak_elemen(df.shape[1]-2,df) print(kelas,outlook,temp,humidity,windy) ['no', 'yes'] ['sunny', 'overcast', 'rainy'] ['hot', 'mild', 'cool'] ['high', 'normal'] [False, True] Fungsi countvKelas untuk menghitung berapa perbandingan setiap elemen yang terdapat di class. # menentukan count value pada Kelas def countvKelas(kelas,kolomKelas,data): hasil=[] for x in range(len(kelas)): hasil.append(0) for i in range (len(data)): for j in range (len(kelas)): if data.values.tolist()[i][kolomKelas] == kelas[j]: hasil[j]+=1 return hasil pKelas=countvKelas(kelas,df.shape[1]-1,df) pKelas [5, 9] untuk fiture menggunakan fungsi countvJenis, karena menghitung perbandingan elemen-elemen dalam sebuah fiture berdasarkan setiap elemen yang berada di class. Fungsi t_list untuk membantu penghitungan. # menentukan count value pada jenis tiap atribut def countvJenis(jenis,kelas,kolomJenis,kolomKelas,data): hasil=[] for x in range (len(kelas)): hasil.append(0) for i in range (len(data)): if data.values.tolist()[i][kolomJenis] == jenis: for j in range (len(kelas)): if data.values.tolist()[i][kolomKelas] == kelas[j]: hasil[j]+=1 return hasil def t_list(atribut,n): temp=[] for i in range(len(atribut)): temp.append(countvJenis(atribut[i],kelas,df.shape[1]-n,df.shape[1]-1,df)) return temp tOutlook=t_list(outlook,5) tTemp=t_list(temp,4) tHum=t_list(humidity,3) tWin=t_list(windy,2) print(tOutlook, tTemp, tHum, tWin) [[3, 2], [0, 4], [2, 3]] [[2, 2], [2, 4], [1, 3]] [[4, 3], [1, 6]] [[2, 6], [3, 3]] Fungsi entropy untuk Menghitung nilai entropy pada sebuah fiture/class. fungsi e_list untuk mempermudah penghitungan entropy setiap elemen di dalam sebuah fiture. # menentukan nilai entropy target def entropy(T): hasil=0 jumlah=0 for y in T: jumlah+=y for z in range (len(T)): if jumlah!=0: T[z]=T[z]/jumlah for i in T: if i != 0: hasil-=i*math.log(i,2) return hasil def e_list(atribut,n): temp=[] tx=t_list(atribut,n) for i in range (len(atribut)): ent=entropy(tx[i]) temp.append(ent) return temp eOutlook=e_list(outlook,5) eTemp=e_list(temp,4) eHum=e_list(humidity,3) eWin=e_list(windy,2) print(\"Sunny, Overcast, Rainy\",eOutlook) print(\"Hot, Mild, Cold\", eTemp) print(\"High, Normal\", eHum) print(\"False, True\", eWin) Sunny, Overcast, Rainy [0.9709505944546686, 0.0, 0.9709505944546686] Hot, Mild, Cold [1.0, 0.9182958340544896, 0.8112781244591328] High, Normal [0.9852281360342516, 0.5916727785823275] False, True [0.8112781244591328, 1.0] Gain Gain atau Information Gain adalah salah satu metode untuk seleksi fitur, berdasarkan perankingan fiture-fiture yang memiliki nilai gain tertinggi ke terendah. Image(\"Gain.jpeg\") Keterangan : Entropy (T) = nilai entropy class Tx,v/T = Probability fiture x E(Tx,v) = Entropy elemen dalam fiture x x = fitur Code untuk menghitung Gain. def gain(T_list,E_list,pKelas,data): txv=0 for i in range (len(E_list)): jumlah=0 for y in range (len(T_list[i])): jumlah+=T_list[i][y] txv+=jumlah/(len(data))*(E_list[i]) eUtama=entropy(pKelas) hasil=eUtama-txv return hasil from IPython.display import HTML, display import tabulate table=[ [\"Fiture\"]+[\"Jenis\"]+[\"no\"]+[\"yes\"]+[\"Entropy\"]+[\"Gain\"], [\"OUTLOOK\"]+[\"Sunny\"]+[tOutlook[0][0]]+[tOutlook[0][1]]+[eOutlook[0]]+[gain(tOutlook,eOutlook,pKelas,df)], [\"\"]+[\"Overcast\"]+[tOutlook[1][0]]+[tOutlook[1][1]]+[eOutlook[1]]+[], [\"\"]+[\"Rainy\"]+[tOutlook[2][0]]+[tOutlook[2][1]]+[eOutlook[2]]+[], [\"TEMPERATURE\"]+[\"Hot\"]+[tTemp[0][0]]+[tTemp[0][1]]+[eTemp[0]]+[gain(tTemp,eTemp,pKelas,df)], [\"\"]+[\"Mild\"]+[tTemp[1][0]]+[tTemp[1][1]]+[eTemp[1]]+[], [\"\"]+[\"Cool\"]+[tTemp[2][0]]+[tTemp[2][1]]+[eTemp[2]]+[], [\"HUMIDITY\"]+[\"High\"]+[tHum[0][0]]+[tHum[0][1]]+[eHum[0]]+[gain(tHum,eHum,pKelas,df)], [\"\"]+[\"Normal\"]+[tHum[1][0]]+[tHum[1][1]]+[eHum[1]]+[], [\"WINDY\"]+[\"False\"]+[tWin[0][0]]+[tWin[0][1]]+[eWin[0]]+[gain(tWin,eWin,pKelas,df)], [\"\"]+[\"True\"]+[tWin[1][0]]+[tWin[1][1]]+[eWin[1]]+[], ] print(\"Hasil penghitungan Entropy dan Gain setiap Fiture:\") display(HTML(tabulate.tabulate(table, tablefmt='html'))) Hasil penghitungan Entropy dan Gain setiap Fiture: Fiture Jenis no yes Entropy Gain OUTLOOK Sunny 3 2 0.9709505944546686 0.2467498197744391 Overcast 0 4 0.0 Rainy 2 3 0.9709505944546686 TEMPERATURE Hot 2 2 1.0 0.029222565658954647 Mild 2 4 0.9182958340544896 Cool 1 3 0.8112781244591328 HUMIDITY High 4 3 0.9852281360342516 0.15183550136234136 Normal 1 6 0.5916727785823275 WINDY False 2 6 0.8112781244591328 0.04812703040826927 True 3 3 1.0 from IPython.display import HTML, display import tabulate table=[ [\"Fiture\"]+[\"GAIN\"], [\"OUTLOOK\"]+[gain(tOutlook,eOutlook,pKelas,df)], [\"TEMPERATURE\"]+[gain(tTemp,eTemp,pKelas,df)], [\"HUMIDITY\"]+[gain(tHum,eHum,pKelas,df)], [\"WINDY\"]+[gain(tWin,eWin,pKelas,df)], ] print(\"Perhatikan Gain pada setiap fiture, urutkan Gain dari yang tertinggi ke rendah untuk meranking fiture:\") display(HTML(tabulate.tabulate(table, tablefmt='html'))) Perhatikan Gain pada setiap fiture, urutkan Gain dari yang tertinggi ke rendah untuk meranking fiture: Fiture GAIN OUTLOOK 0.2467498197744391 TEMPERATURE 0.029222565658954647 HUMIDITY 0.15183550136234136 WINDY 0.04812703040826927 from IPython.display import HTML, display import tabulate nul=[ [\"Fiture\"]+[\"GAIN\"]+[\"RANK\"], [\"OUTLOOK\"]+[gain(tOutlook,eOutlook,pKelas,df)]+[\"1\"], [\"TEMPERATURE\"]+[gain(tTemp,eTemp,pKelas,df)]+[\"4\"], [\"HUMIDITY\"]+[gain(tHum,eHum,pKelas,df)]+[\"2\"], [\"WINDY\"]+[gain(tWin,eWin,pKelas,df)]+[\"3\"], ] table=[ [\"Fiture\"]+[\"GAIN\"]+[\"RANK\"], [\"OUTLOOK\"]+[gain(tOutlook,eOutlook,pKelas,df)]+[\"1\"], [\"HUMIDITY\"]+[gain(tHum,eHum,pKelas,df)]+[\"2\"], [\"WINDY\"]+[gain(tWin,eWin,pKelas,df)]+[\"3\"], [\"TEMPERATURE\"]+[gain(tTemp,eTemp,pKelas,df)]+[\"4\"], ] display(HTML(tabulate.tabulate(nul, tablefmt='html'))) print(\"Setelah di urut berdasarkan rank :\") display(HTML(tabulate.tabulate(table, tablefmt='html'))) Fiture GAIN RANK OUTLOOK 0.2467498197744391 1 TEMPERATURE 0.029222565658954647 4 HUMIDITY 0.15183550136234136 2 WINDY 0.04812703040826927 3 Setelah di urut berdasarkan rank : Fiture GAIN RANK OUTLOOK 0.2467498197744391 1 HUMIDITY 0.15183550136234136 2 WINDY 0.04812703040826927 3 TEMPERATURE 0.029222565658954647 4 Jadi kita bisa mengolah data hanya menggunakan 1/2/3 fitur. semakin sedikit fiture yang digunakan semakin sedikit waktu yg diperlukan untuk mengolah data. Ketepatan jumlah fitur yang akan dipakai. dapat diperiksa keefektifannya terlebih dahulu","title":"Tugas 3"},{"location":"DataMiningTg3/#seleksi-fitur","text":"Seleksi fitur adalah teknik untuk memilih fitur penting dan relevan terhadap data dan mengurangi fitur yang tidak relevan. Seleksi fitur bertujuan untuk memilih fitur terbaik dari suatu kumpulan data fitur. Banyak cara untuk melakukan seleksi fitur. seperti : - Information Gain - Relief - Fast Correlation Based Filter dll Kali ini Metode yang digunakan adalah Information Gain. Metode Information Gain adalah metode yang menggunakan teknik scoring untuk pembobotan sebuah fitur dengan menggunakan maksimal entropy. Fitur yang dipilih adalah fitur dengan nilai Information Gain yang lebih besar atau sama dengan nilai threshold tertentu. Contoh Data Keputusan Bermain Tenis from IPython.display import Image import pandas as pd import math df=pd.read_csv('feature selection.csv') df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } outlook temperature humidity windy play 0 sunny hot high False no 1 sunny hot high True no 2 overcast hot high False yes 3 rainy mild high False yes 4 rainy cool normal False yes 5 rainy cool normal True no 6 overcast cool normal True yes 7 sunny mild high False no 8 sunny cool normal False yes 9 rainy mild normal False yes 10 sunny mild normal True yes 11 overcast mild high True yes 12 overcast hot normal False yes 13 rainy mild high True no","title":"Seleksi Fitur"},{"location":"DataMiningTg3/#mencari-entropy","text":"Untuk menghitung Information gain perlu dihitung dahulu nilai informasi dalam suatu bits dari suatu kumpulan obyek. Cara penghitungan dilakukan dengan menggunakan konsep entropi. Entropi menyatakan impurity suatu kumpulan obyek . Berikut merupakan definisi dari entropi suatu ruang sampel data (T): Image(\"Entropy.png\") Keterangan : T = ruang sampel data yang di gunakaan untuk data pelatihan n = jumlah partisi Pi = Probability dari Pi terhadap P untuk mempermudah penghitungan saya menggunakan fungsi pembantu, seperti fungsi banyak_elemen untuk mengecek ada berapa elemen dalam sebuah kolom atau fiture/class. # menentukan value atau jenis pada atribut def banyak_elemen (kolom, data): kelas=[] for i in range (len(data)): if data.values.tolist()[i][kolom] not in kelas: kelas.append(data.values.tolist()[i][kolom]) return kelas kelas=banyak_elemen(df.shape[1]-1, df) outlook=banyak_elemen(df.shape[1]-5,df) temp=banyak_elemen(df.shape[1]-4,df) humidity=banyak_elemen(df.shape[1]-3,df) windy=banyak_elemen(df.shape[1]-2,df) print(kelas,outlook,temp,humidity,windy) ['no', 'yes'] ['sunny', 'overcast', 'rainy'] ['hot', 'mild', 'cool'] ['high', 'normal'] [False, True] Fungsi countvKelas untuk menghitung berapa perbandingan setiap elemen yang terdapat di class. # menentukan count value pada Kelas def countvKelas(kelas,kolomKelas,data): hasil=[] for x in range(len(kelas)): hasil.append(0) for i in range (len(data)): for j in range (len(kelas)): if data.values.tolist()[i][kolomKelas] == kelas[j]: hasil[j]+=1 return hasil pKelas=countvKelas(kelas,df.shape[1]-1,df) pKelas [5, 9] untuk fiture menggunakan fungsi countvJenis, karena menghitung perbandingan elemen-elemen dalam sebuah fiture berdasarkan setiap elemen yang berada di class. Fungsi t_list untuk membantu penghitungan. # menentukan count value pada jenis tiap atribut def countvJenis(jenis,kelas,kolomJenis,kolomKelas,data): hasil=[] for x in range (len(kelas)): hasil.append(0) for i in range (len(data)): if data.values.tolist()[i][kolomJenis] == jenis: for j in range (len(kelas)): if data.values.tolist()[i][kolomKelas] == kelas[j]: hasil[j]+=1 return hasil def t_list(atribut,n): temp=[] for i in range(len(atribut)): temp.append(countvJenis(atribut[i],kelas,df.shape[1]-n,df.shape[1]-1,df)) return temp tOutlook=t_list(outlook,5) tTemp=t_list(temp,4) tHum=t_list(humidity,3) tWin=t_list(windy,2) print(tOutlook, tTemp, tHum, tWin) [[3, 2], [0, 4], [2, 3]] [[2, 2], [2, 4], [1, 3]] [[4, 3], [1, 6]] [[2, 6], [3, 3]] Fungsi entropy untuk Menghitung nilai entropy pada sebuah fiture/class. fungsi e_list untuk mempermudah penghitungan entropy setiap elemen di dalam sebuah fiture. # menentukan nilai entropy target def entropy(T): hasil=0 jumlah=0 for y in T: jumlah+=y for z in range (len(T)): if jumlah!=0: T[z]=T[z]/jumlah for i in T: if i != 0: hasil-=i*math.log(i,2) return hasil def e_list(atribut,n): temp=[] tx=t_list(atribut,n) for i in range (len(atribut)): ent=entropy(tx[i]) temp.append(ent) return temp eOutlook=e_list(outlook,5) eTemp=e_list(temp,4) eHum=e_list(humidity,3) eWin=e_list(windy,2) print(\"Sunny, Overcast, Rainy\",eOutlook) print(\"Hot, Mild, Cold\", eTemp) print(\"High, Normal\", eHum) print(\"False, True\", eWin) Sunny, Overcast, Rainy [0.9709505944546686, 0.0, 0.9709505944546686] Hot, Mild, Cold [1.0, 0.9182958340544896, 0.8112781244591328] High, Normal [0.9852281360342516, 0.5916727785823275] False, True [0.8112781244591328, 1.0]","title":"Mencari Entropy"},{"location":"DataMiningTg3/#gain","text":"Gain atau Information Gain adalah salah satu metode untuk seleksi fitur, berdasarkan perankingan fiture-fiture yang memiliki nilai gain tertinggi ke terendah. Image(\"Gain.jpeg\") Keterangan : Entropy (T) = nilai entropy class Tx,v/T = Probability fiture x E(Tx,v) = Entropy elemen dalam fiture x x = fitur Code untuk menghitung Gain. def gain(T_list,E_list,pKelas,data): txv=0 for i in range (len(E_list)): jumlah=0 for y in range (len(T_list[i])): jumlah+=T_list[i][y] txv+=jumlah/(len(data))*(E_list[i]) eUtama=entropy(pKelas) hasil=eUtama-txv return hasil from IPython.display import HTML, display import tabulate table=[ [\"Fiture\"]+[\"Jenis\"]+[\"no\"]+[\"yes\"]+[\"Entropy\"]+[\"Gain\"], [\"OUTLOOK\"]+[\"Sunny\"]+[tOutlook[0][0]]+[tOutlook[0][1]]+[eOutlook[0]]+[gain(tOutlook,eOutlook,pKelas,df)], [\"\"]+[\"Overcast\"]+[tOutlook[1][0]]+[tOutlook[1][1]]+[eOutlook[1]]+[], [\"\"]+[\"Rainy\"]+[tOutlook[2][0]]+[tOutlook[2][1]]+[eOutlook[2]]+[], [\"TEMPERATURE\"]+[\"Hot\"]+[tTemp[0][0]]+[tTemp[0][1]]+[eTemp[0]]+[gain(tTemp,eTemp,pKelas,df)], [\"\"]+[\"Mild\"]+[tTemp[1][0]]+[tTemp[1][1]]+[eTemp[1]]+[], [\"\"]+[\"Cool\"]+[tTemp[2][0]]+[tTemp[2][1]]+[eTemp[2]]+[], [\"HUMIDITY\"]+[\"High\"]+[tHum[0][0]]+[tHum[0][1]]+[eHum[0]]+[gain(tHum,eHum,pKelas,df)], [\"\"]+[\"Normal\"]+[tHum[1][0]]+[tHum[1][1]]+[eHum[1]]+[], [\"WINDY\"]+[\"False\"]+[tWin[0][0]]+[tWin[0][1]]+[eWin[0]]+[gain(tWin,eWin,pKelas,df)], [\"\"]+[\"True\"]+[tWin[1][0]]+[tWin[1][1]]+[eWin[1]]+[], ] print(\"Hasil penghitungan Entropy dan Gain setiap Fiture:\") display(HTML(tabulate.tabulate(table, tablefmt='html'))) Hasil penghitungan Entropy dan Gain setiap Fiture: Fiture Jenis no yes Entropy Gain OUTLOOK Sunny 3 2 0.9709505944546686 0.2467498197744391 Overcast 0 4 0.0 Rainy 2 3 0.9709505944546686 TEMPERATURE Hot 2 2 1.0 0.029222565658954647 Mild 2 4 0.9182958340544896 Cool 1 3 0.8112781244591328 HUMIDITY High 4 3 0.9852281360342516 0.15183550136234136 Normal 1 6 0.5916727785823275 WINDY False 2 6 0.8112781244591328 0.04812703040826927 True 3 3 1.0 from IPython.display import HTML, display import tabulate table=[ [\"Fiture\"]+[\"GAIN\"], [\"OUTLOOK\"]+[gain(tOutlook,eOutlook,pKelas,df)], [\"TEMPERATURE\"]+[gain(tTemp,eTemp,pKelas,df)], [\"HUMIDITY\"]+[gain(tHum,eHum,pKelas,df)], [\"WINDY\"]+[gain(tWin,eWin,pKelas,df)], ] print(\"Perhatikan Gain pada setiap fiture, urutkan Gain dari yang tertinggi ke rendah untuk meranking fiture:\") display(HTML(tabulate.tabulate(table, tablefmt='html'))) Perhatikan Gain pada setiap fiture, urutkan Gain dari yang tertinggi ke rendah untuk meranking fiture: Fiture GAIN OUTLOOK 0.2467498197744391 TEMPERATURE 0.029222565658954647 HUMIDITY 0.15183550136234136 WINDY 0.04812703040826927 from IPython.display import HTML, display import tabulate nul=[ [\"Fiture\"]+[\"GAIN\"]+[\"RANK\"], [\"OUTLOOK\"]+[gain(tOutlook,eOutlook,pKelas,df)]+[\"1\"], [\"TEMPERATURE\"]+[gain(tTemp,eTemp,pKelas,df)]+[\"4\"], [\"HUMIDITY\"]+[gain(tHum,eHum,pKelas,df)]+[\"2\"], [\"WINDY\"]+[gain(tWin,eWin,pKelas,df)]+[\"3\"], ] table=[ [\"Fiture\"]+[\"GAIN\"]+[\"RANK\"], [\"OUTLOOK\"]+[gain(tOutlook,eOutlook,pKelas,df)]+[\"1\"], [\"HUMIDITY\"]+[gain(tHum,eHum,pKelas,df)]+[\"2\"], [\"WINDY\"]+[gain(tWin,eWin,pKelas,df)]+[\"3\"], [\"TEMPERATURE\"]+[gain(tTemp,eTemp,pKelas,df)]+[\"4\"], ] display(HTML(tabulate.tabulate(nul, tablefmt='html'))) print(\"Setelah di urut berdasarkan rank :\") display(HTML(tabulate.tabulate(table, tablefmt='html'))) Fiture GAIN RANK OUTLOOK 0.2467498197744391 1 TEMPERATURE 0.029222565658954647 4 HUMIDITY 0.15183550136234136 2 WINDY 0.04812703040826927 3 Setelah di urut berdasarkan rank : Fiture GAIN RANK OUTLOOK 0.2467498197744391 1 HUMIDITY 0.15183550136234136 2 WINDY 0.04812703040826927 3 TEMPERATURE 0.029222565658954647 4 Jadi kita bisa mengolah data hanya menggunakan 1/2/3 fitur. semakin sedikit fiture yang digunakan semakin sedikit waktu yg diperlukan untuk mengolah data. Ketepatan jumlah fitur yang akan dipakai. dapat diperiksa keefektifannya terlebih dahulu","title":"Gain"}]}